use strict;
use warnings;
use Sys::Syslog qw(:standard :macros);
our $config;
use Date::Parse;

# old style function
sub monitorNtp {
  my $base=shift;$base = ".$base";
  my $o=shift;
  my $nsrv=shift;
  my $t=gettimeofday();
  my $cmd="/usr/sbin/ntpdate -t $config->{'cmd_timeout'} -q4 $nsrv";
  my $v;

  foreach (`$cmd`) {
    chomp;
    $v=(split )[9] if ( /time server/ );
  }
  my $r = $? >> 8;
  $$o{$base. '.1.1'} = $v;
  $$o{$base. '.2.1'} = $cmd;
  $$o{$base. '.2.2'} = gettimeofday()-$t;
  $$o{$base. '.2.3'} = $r;
  return $r;
}
# apache httpd mod_status dashboard

#Total Accesses: 58760
#Total kBytes: 37099
#CPULoad: .0188875
#Uptime: 426632
#ReqPerSec: .13773
#BytesPerSec: 89.0448
#BytesPerReq: 646.518
#BusyWorkers: 1
#IdleWorkers: 99

#Scoreboard Key:
#   "_" Waiting for Connection, 
#   "W" Sending Reply, 
#   "R" Reading Request,
#   "K" KeepAlive (read), 
#   "D" DNS Lookup, 

sub apacheStatusMIB {
  my $o=shift;
  my $cfg=shift;
  my $cmd="curl -s -m $config->{'cmd_timeout'} ";
  my $i=1; # i is unused
  my $r=0;
  my $t=gettimeofday();

  foreach my $a (@{$cfg->{'args'}}) {
    my $ts=gettimeofday();
    foreach (`$cmd $a->{'status_url'}`) {
      chomp;
      if ( /Scoreboard/ ) {
        my $s=(split )[1];
        $$o{"apsWaitingForConnection.$i"}=$s=~tr/_/_/; 
        $$o{"apsSendingReply.$i"}=$s=~tr/W/W/; 
        $$o{"apsReadingRequest.$i"}=$s=~tr/R/R/; 
        $$o{"apsKeepAlive.$i"}=$s=~tr/K/K/; 
        $$o{"apsOpenSlots.$i"}=$s=~tr/././; 
        $$o{"apsOtherSlots.$i"}=$s=~tr/DCLGIS//; 
      } elsif ( /^Total Accesses/ ) {
        $$o{"apsTotalAccesses.$i"} = ( split /: / )[1];
      } elsif ( /^CPULoad/ ) {
        $$o{"apsCpuLoad.$i"} = ( split /: / )[1];
      } elsif ( /^Uptime/ ) {
        $$o{"apsUptime.$i"} = ( split /: / )[1];
      } elsif ( /^BusyWorkers/ ) {
        $$o{"apsBusyWorkers.$i"} = ( split /: / )[1];
      } elsif ( /^IdleWorkers/ ) {
        $$o{"apsIdleWorkers.$i"} = ( split /: / )[1];
      } elsif ( /^ReqPerSec/ ) {
        $$o{"apsReqPersSec.$i"} = ( split /: / )[1];
      } elsif ( /^BytesPerSec/ ) {
        $$o{"apsBytesPerSec.$i"} = ( split /: / )[1];
      } elsif ( /^BytesPerReq/ ) {
        $$o{"apsBytesPerReq.$i"} = ( split /: / )[1];
      }
    }

    my $cmd_r = $? >> 8;
    $$o{"apsIndex.$i"} = $i;
    $$o{"apsCmdExecTime.$i"} = sprintf('%.3f',scalar gettimeofday() - $ts);
    $$o{"apsCmdExecStatus.$i"} = $cmd_r;
    $$o{"apsUrl.$i"} = (defined($a->{'description'})?$a->{'description'}:'') . "[$a->{'status_url'}]";
    if ( ! $cmd_r ) {
      my $allslots = $$o{"apsWaitingForConnection.$i"} + $$o{"apsSendingReply.$i"} + $$o{"apsReadingRequest.$i"} + $$o{"apsKeepAlive.$i"} + $$o{"apsOtherSlots.$i"} + $$o{"apsOpenSlots.$i"};
      my $busyslots = $$o{"apsSendingReply.$i"} + $$o{"apsReadingRequest.$i"} + $$o{"apsKeepAlive.$i"} + $$o{"apsOtherSlots.$i"};
      $$o{"apsSlotsUsage.$i"} = sprintf('%.2f', $busyslots*100/$allslots );
    }
    $r = $cmd_r if $cmd_r;
    $i++;
  }
  $$o{'apsFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'apsFuncExecStatus'} = $r;
  return  $r;
}

sub httpResponseMIB {
  my $o=shift;
  my $cfg=shift;
  my $cmd="curl -v -s -m $config->{'cmd_timeout'} "; #don't use -v -s -m options for curl args
  my $i=1; 
  my $r=0;
  my $t=gettimeofday();

  foreach my $a (@{$cfg->{'args'}}) {
    my $ts=gettimeofday();
    $$o{"httpRespMatched.$i"} = defined($a->{'match'})?2:0;
    $$o{"httpRespMatchString.$i"} = '';
    foreach (`($cmd $a->{'curl'} | sed 's/^/STDOUT:/') 2>&1`) {
      chomp;
      if ( /^STDOUT/ and defined($a->{'match'}) and /$a->{'match'}/ ) {
        $$o{"httpRespMatched.$i"} = 1;
        $$o{"httpRespMatchString.$i"} = $1 if defined($1);
      }
      $$o{"httpRespCode.$i"} = ( split )[2] if ( /^< HTTP\// );
    }
    # don't return unmatch in the case of ERROR http code
    $$o{"httpRespMatched.$i"} = 0 if ( defined($$o{"httpRespCode.$i"}) and $$o{"httpRespCode.$i"} > 307 );
    my $cmd_r = $? >> 8;
    $$o{"httpRespIndex.$i"} = $i;
    $$o{"httpRespCmdExecTime.$i"} = sprintf('%.3f',scalar gettimeofday() - $ts);
    $$o{"httpRespCmdExecStatus.$i"} = $cmd_r;
    $$o{"httpRespCurlArgs.$i"} = (defined($a->{'description'})?$a->{'description'}:'') . "[$a->{'curl'}]";
    $$o{"httpRespMonitoringTemplate.$i"} = defined($a->{'monitoringTemplate'})?$a->{'monitoringTemplate'}:'';
    $r = $cmd_r if $cmd_r;
    $i++;
  }
  $$o{'httpRespFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'httpRespFuncExecStatus'} = $r;
  return  $r;
}

sub ntpSyncMIB {
  my $o=shift;
  my $cfg=shift;
  my $t=gettimeofday();
  my $cmd="/usr/sbin/ntpdate -t $config->{'cmd_timeout'} -q4 $cfg->{'args'}[0]->{'server'}";
  my $v;

  foreach (`$cmd`) {
    chomp;
    $v=(split )[9] if ( /time server/ );
  }
  my $r = $? >> 8;
  $$o{'ntpSyncStatus'} = sprintf('%.3f', $v) if defined($v);
  $$o{'ntpSyncServer'} = $cfg->{'args'}[0]->{'server'};
  $$o{'ntpSyncFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'ntpSyncExecStatus'} = $r;
  return $r;
}

sub procCountMIB {
  my $o = shift;
  my $cfg = shift;
  my $t = gettimeofday();
  $$o{'procTotal'} =    0;
  $$o{'procRunning'} =  0;
  $$o{'procSleeping'} = 0;
  $$o{'procStopped'} =  0;
  $$o{'procZombie'} =   0;
  $$o{'procUninterruptible'} =   0;

  foreach(`ps axo pid=,vsize=,stat=,lstart=`) {
    chomp;
    my ($not_used_but_needed,$pid, $vsize, $stat, $lstart) = split /\s+/,$_,5;
    if ( !defined($cfg->{'args'}[0]->{'extendedInfo'}) or $cfg->{'args'}[0]->{'extendedInfo'} eq 'on' ) {
      $$o{"procVirtualMemory.$pid"} = $vsize;
      $$o{"procStartTime.$pid"} = str2time($lstart);
      if ( opendir ( my $dh, "/proc/$pid/fd" ) ) {
        $$o{"procOpenFdCount.$pid"} = $#{[readdir $dh]} - 1;
        closedir $dh;
      } 
    }

    $$o{'procTotal'}++;
    $$o{'procRunning'}++  if $stat =~ /^R/;
    $$o{'procSleeping'}++ if $stat =~ /^S/;
    $$o{'procStopped'}++  if $stat =~ /^T/;
    $$o{'procZombie'}++   if $stat =~ /^Z/;
    $$o{'procUninterruptible'}++  if $stat =~ /^D/;
  }
  my $r = $? >> 8;
  $$o{'procFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'procExecStatus'} = $r;
  return $r;
}
  
sub ip_conntrackMIB {
  my $o = shift;
  my $t = gettimeofday();
  my ($cmd, $count, $max, $r);

  if (-f "/proc/sys/net/ipv4/ip_conntrack_max") {
    $cmd="cat /proc/sys/net/ipv4/netfilter/ip_conntrack_count /proc/sys/net/ipv4/ip_conntrack_max | tr '\n' ' '";
  } elsif (-f "/proc/sys/net/netfilter/nf_conntrack_max") {
    $cmd="cat /proc/sys/net/netfilter/nf_conntrack_count /proc/sys/net/netfilter/nf_conntrack_max | tr '\n' ' '";
  }
  
  if ( defined($cmd) ) {
    $$o{'ip-conntrackLoaded'} = 1;
    foreach (`$cmd`) {
      chomp;
      ($count, $max)=split;
    }
    $r = $? >> 8;
    if ( ! $r ) {
      $$o{'ip-conntrackCount'} = $count;
      $$o{'ip-conntrackMax'} = $max;
      $$o{'ip-conntrackUsage'} = sprintf('%.0f', 100*$count/$max);
    }
  } else {
    $$o{'ip-conntrackLoaded'} = 0;
    $r = 0;
  }

  $$o{'ip-conntrackFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'ip-conntrackExecStatus'} = $r;
  return $r;
}

sub dnsLookUpMIB {
  my $o=shift;
  my $cfg=shift;
  my $cmd="/usr/bin/host -W $config->{'cmd_timeout'}";
  my $i=1;
  my $r=0;
  my $t=gettimeofday();

  foreach my $a (@{$cfg->{'args'}}) {
    my $lookup_ips = '';
    my $ts=gettimeofday();
    foreach (`$cmd $a->{'fqdn'}`) {
      chomp;
      my $s=$_;
      if ( /has address/ ) {
        $lookup_ips .=  (split / /,$s)[3] . ',';
      }
    }
    my $lookup_r = $? >> 8;
    $$o{"dnsIndex.$i"} = $i;
    $$o{"dnsNameLookUp.$i"} = $a->{'fqdn'};
    $$o{"dnsNameResolvedIp.$i"} = $lookup_ips;
    $$o{"dnsLookUpExecTime.$i"} = sprintf('%.3f',scalar gettimeofday() - $ts);
    $$o{"dnsLookUpExecStatus.$i"} = $lookup_r;
    $r = $lookup_r if $lookup_r;
    $i++;
  }
  $$o{'dnsLookUpFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'dnsLookUpFuncExecStatus'} = $r;
  return  $r;
}

sub osInfoMIB {
  my $o=shift;
  my $r;
  my $osRelease='';
  $$o{'osinfoRelease'} = `uname -rm`;
  $r = $? >> 8;
  return $r if $r;
  chomp $$o{'osinfoRelease'};
  if ( -f '/etc/redhat-release' ) {
    $osRelease = `head -1 /etc/redhat-release`;
    chomp $osRelease;
  } elsif ( -f '/etc/fedora-release' ) {
    $osRelease = `head -1 /etc/fedora-release`;
    chomp $osRelease;
  } elsif ( -f '/etc/debian_version' ) {
    $osRelease = `head -1 /etc/debian_version`;
    chomp $osRelease;
    $osRelease = "Debian $osRelease";
  }
  $r = $? >> 8;
  $$o{'osinfoRelease'} = "$osRelease $$o{'osinfoRelease'}";
  $$o{'osinfoSoftwareLastChange'} =  (stat('/var/lib/rpm/Packages'))[9] if ( -f '/var/lib/rpm/Packages' );
  return $r;  
}

sub lastLoginsMIB {
  my $o=shift;
  my $i=1;
  my $r;
  my $t=gettimeofday();

  foreach  (`w -h`) {
    chomp;
    $$o{"loggedInUserInfo.$i"} = $_;
    $i++;
  }
  $$o{'loggedInUsersCount'} = $i-1;

  $r = $? >> 8;

  $i=1;  
  my $cmd = ($^O =~ 'linux')?'last -20 -w':'last -20';
  foreach  (`$cmd`) {
    chomp;
    next if ( /^$/ );
    if ( /^wtmp begins/ ) {
      $$o{'wtmpBegins'} = $_;
      next;
    }

#    $$o{"lastUserIndex.$i"} = $i;
    $$o{"lastUserInfo.$i"} = $_;
    $i++;
  }
  $r = $r || ($? >> 8);
  return $r;
}

sub execCommandMIB {
  my $o=shift;
  my $cfg=shift;
  my $i=1; 
  my $r=0;
  my $t=gettimeofday();

  foreach my $a (@{$cfg->{'args'}}) {
    my $ts=gettimeofday();
    $$o{"cmdOutMatched.$i"} = defined($a->{'match'})?2:0;
    $$o{"cmdOutMatchString.$i"} = '';

    foreach (`$a->{'cmd'}`) {
      chomp;
      if ( defined($a->{'match'}) and /$a->{'match'}/ ) {
        $$o{"cmdOutMatched.$i"} = 1;
        $$o{"cmdOutMatchString.$i"} = $1;
      }
    }

    my $cmd_r = $? >> 8;
    $$o{"cmdIndex.$i"} = $i;
    $$o{"cmdExecTime.$i"} = sprintf('%.3f',scalar gettimeofday() - $ts);
    $$o{"cmdExecStatus.$i"} = $cmd_r;
    $$o{"cmdName.$i"} = (defined($a->{'description'})?$a->{'description'}:'') . "[$a->{'cmd'}]";
    $$o{"cmdMonitoringTemplate.$i"} = defined($a->{'monitoringTemplate'})?$a->{'monitoringTemplate'}:'';
    $r = $cmd_r if $cmd_r;
    $i++;
  }

  $$o{'cmdFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'cmdFuncExecStatus'} = $r;
  return $r;
}

sub rndcStatMIB {
  my $o=shift;
  my $cfg=shift;
  my $t=gettimeofday();
  my $r;
  if (! defined($cfg->{'args'}[0]->{'pre_cmd'}) ) {
    $cfg->{'args'}[0]->{'pre_cmd'}="rm -f $cfg->{'args'}[0]->{'stat_file'} && /usr/sbin/rndc stats";
  }
  `$cfg->{'args'}[0]->{'pre_cmd'}` unless ( $cfg->{'args'}[0]->{'pre_cmd'} eq '' );
  $r = $? >> 8;
  return $r if $r; 

  if (-f "$cfg->{'args'}[0]->{'stat_file'}") {
    foreach (`cat $cfg->{'args'}[0]->{'stat_file'}`) {
      chomp;
      if ( /(^success\s|successful answer)/ ) {
        $$o{"rndcSuccess"} = ( split /\s+/)[1];
      } elsif ( /in authoritative answer/ ) {
        $$o{"rndcAuthoritative"} = ( split /\s+/)[1];
      } elsif ( /in non authoritative answer/ ) {
        $$o{"rndcNonAuthoritative"} = ( split /\s+/)[1];
      } elsif ( /(^nxrrset\s|in nxrrset)/ ) {
        $$o{"rndcNxrrset"} = ( split /\s+/)[1];
      } elsif ( /(^failure\s|in SERVFAIL)/ ) {
        $$o{"rndcServfail"} = ( split /\s+/)[1];
      } elsif ( /(^nxdomain\s|in NXDOMAIN)/ ) {
        $$o{"rndcNxdomain"} = ( split /\s+/)[1];
      } elsif ( /(^recursion\s|caused recursion)/ ) {
        $$o{"rndcRecursion"} = ( split /\s+/)[1];
      } elsif ( /duplicate queries/ ) {
        $$o{"rndcDuplicate"} = ( split /\s+/)[1];
      } elsif ( /queries dropped/ ) {
        $$o{"rndcDropped"} = ( split /\s+/)[1];
      } elsif ( /other query failures/ ) {
        $$o{"rndcOtherFailures"} = ( split /\s+/)[1];
      }
    }
    $r = $? >> 8;
  } else {
    $r = -1;
  }
  $$o{"rndcAuthoritative"} = 0 unless defined($$o{"rndcAuthoritative"});
  $$o{"rndcNonAuthoritative"} = 0 unless defined($$o{"rndcNonAuthoritative"});
  $$o{"rndcDuplicate"} = 0 unless defined($$o{"rndcDuplicate"});
  $$o{"rndcDropped"} = 0 unless defined($$o{"rndcDropped"});
  $$o{"rndcOtherFailures"} = 0 unless defined($$o{"rndcOtherFailures"});

  $$o{'rndcFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'rndcExecStatus'} = $r;
  return $r;
}

sub mailqMIB {
  my $o=shift;
  my $c=0;
  my $r=0;
  my $t=gettimeofday();
  foreach (`mailq`) {
    chomp;
    last if ( /Mail queue is empty/ );
    $c++ if ( /^[\d[A-F]{10}/ );
  }
  $r = $? >> 8;
  $$o{'mailqCount'} = $c unless $r;
  $$o{'mailqFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'mailqExecStatus'} = $r;
  return $r;
}

sub vmstatMIB {
  my $o=shift;
  my $r=0;
  my $t=gettimeofday();

  my $c=`which vmstat`; chomp $c;
  
  if ( -x $c ) {
    foreach (`vmstat -s`) {
      chomp;
      s/^\s+//;
      my ($v,$c) = split / +/, $_, 2;
      if ( $c eq 'pages swapped in' ) {
        $$o{'vmstatPswpin'} = $v; 
      } elsif ( $c eq 'pages swapped out' ) {
        $$o{'vmstatPswpout'} = $v; 
      } elsif ( $c eq 'interrupts' ) {
        $$o{'vmstatInterrupts'} = $v; 
      } elsif ( $c eq 'CPU context switches' ) {
        $$o{'vmstatCntxSwitches'} = $v; 
      }     
    }

    $r = $? >> 8;
  } else {
    logMessage(LOG_WARNING, "vmstat is not found");
    $r = -1;
  }
  $$o{'vmstatFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'vmstatExecStatus'} = $r;
  return $r;
}

sub pingStatMIB {
  my $o = shift;
  my $cfg = shift;
  my $r = 0;
  my $t = gettimeofday();
  my @tdata;
  my $i=0;

  foreach my $a ( @{$cfg->{'args'}} ) {
    my $ts = gettimeofday();
    my $count = defined($a->{'count'})?$a->{'count'}:10;
    my $options = defined($a->{'options'})?$a->{'options'}:'';
    $tdata[$i]->{'pid'} = open( $tdata[$i]->{'fh'} , "ping $options -q -c $count $a->{'host'} |" );
    $tdata[$i]->{'host'} = $a->{'host'};
    $i++;
  }
  for( $i=1; $i<=($#tdata+1); $i++ ) {
    while ( readline ( $tdata[$i-1]->{'fh'} ) ) {
      chomp;
      if ( /^(\d+).+transmitted.+ (\d+).+received.+ ([\d\.]+).+loss.+ time (\d+)/ ) {
	      $$o{"pingTransmitted.$i"} = $1;
	      $$o{"pingReceived.$i"} = $2;
	      $$o{"pingLoss.$i"} = $3;
	      $$o{"pingExecTime.$i"} = $4/1000;
      } elsif ( /^(rtt|round-trip).+= ([\d\.]+)\/([\d\.]+)\/([\d\.]+)/ ) {
        $$o{"pingRttMin.$i"} = $2;
        $$o{"pingRttAvg.$i"} = $3;
        $$o{"pingRttMax.$i"} = $4;
      }
    } 
    $$o{"pingIndex.$i"} = $i;
    $$o{"pingHost.$i"} = $tdata[$i-1]->{'host'};
  }

  for( $i=1; $i<=($#tdata+1); $i++ ) {
    waitpid( $tdata[$i-1]->{'pid'}, 0 );
    my $cmd_r = $? >> 8;
    $$o{"pingExecStatus.$i"} = $cmd_r;
    $r = $cmd_r if $cmd_r;
  }

  $$o{'pingFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'pingFuncExecStatus'} = $r;
  return $r;
}

sub diskStatsMIB {
  my $t = gettimeofday();
  my $o=shift;
  my $cfg=shift;
  my $i=1;
  my $r=0;

  my $get_diskstats_command = $cfg->{'args'}[0]->{'command'} || 'cat /proc/diskstats';
  my $match_re = $cfg->{'args'}[0]->{'match'} || '[hsv]d[a-z]+\\d*|c\\d+t\\d+d\\d+s\\d+$|cciss\/c\\d+d\\d+p\\d+|dm-\\d+';
  
  logMessage(LOG_DEBUG, "executing $get_diskstats_command");

  foreach (`$get_diskstats_command 2>/dev/null`) {
    # get contents of a file, split it and fill in the data
    # pretty simple, read mib for description
    # or look at https://www.kernel.org/doc/Documentation/iostats.txt
    # to read the same with more details
    my @block_devices_with_stats = split ;
    next unless $#block_devices_with_stats == 13;
    unless ( $block_devices_with_stats[2] =~ $match_re){
        next;
    }
    logMessage(LOG_DEBUG, "Block device $block_devices_with_stats[2] matched against $match_re");
    $$o{"diskStatsIndex.$i"}               = $i;
    $$o{"diskStatsName.$i"}                = $block_devices_with_stats[2];
    $$o{"diskStatsReadsCompleted.$i"}      = $block_devices_with_stats[3];
    $$o{"diskStatsReadsMerged.$i"}         = $block_devices_with_stats[4];
    $$o{"diskStatsSectorsRead.$i"}         = $block_devices_with_stats[5];
    $$o{"diskStatsMsSpentReading.$i"}      = $block_devices_with_stats[6];
    $$o{"diskStatsWritesCompleted.$i"}     = $block_devices_with_stats[7];
    $$o{"diskStatsWritesMerged.$i"}        = $block_devices_with_stats[8];
    $$o{"diskStatsSectorsWritten.$i"}      = $block_devices_with_stats[9]; 
    $$o{"diskStatsMsSpentWriting.$i"}      = $block_devices_with_stats[10];
    $$o{"diskStatsIOInProgress.$i"}        = $block_devices_with_stats[11];
    $$o{"diskStatsMsSpentInIO.$i"}         = $block_devices_with_stats[12];
    $$o{"diskStatsWeightedMsSpentInIO.$i"} = $block_devices_with_stats[13];

    $i++;
  }

  # prepare return value and fill in some statistics of execution
  $r = $? >> 8;
  $$o{'diskStatsCmdExecStatus'} = $r;
  $$o{'diskStatsCmdExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t );

  return $r;

}

return 1;
